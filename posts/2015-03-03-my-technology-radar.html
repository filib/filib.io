<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Philip is a Ruby and Haskell developer currently working remotely from Melbourne.">
    <title>
      Philip Cunningham -
      
      My Technology Radar
      
    </title>
    <link rel="stylesheet" href="../css/normalize.css">
    <link rel="stylesheet" href="../css/filib.css">
  </head>
  <body>
    <div class="container">
      <div class="row">
        <div class="column one-third">
          <nav class="masthead">
            <ul>
              <li>
                <a href="../">
                  Home
                </a>
              </li>
              </li>
              <li>
                <a href="../about.html">
                  About
                </a>
              </li>
              <li>
                <a href="../rss.xml">
                  RSS
                </a>
              </li>
            </ul>
          </nav>
        </div>
      </div>
      <hr />
      <div class="row">
        <div>
  <h1>
    My Technology Radar
  </h1>
  <section>
    <header>
      <h2>
        2015-03-03
      </h2>
      <p>
        <a href="../tags/radar.html" class="post-category green">radar</a>
      </p>
    </header>

    <div>
      <p>My decisions to learn different technologies have, up until very recently, been fairly ad-hoc. I’d hear about some interesting or novel technology and bookmark it to come back to later. Unsurprisingly this approach is not without its flaws. The main one being that it lacks a clear strategy or structure, making it difficult assess successes and shortcomings in any larger context.</p>
<p>I’ve decided to steal <a href="http://nealford.com/">Neal Ford’s</a> idea of building a <a href="http://devchat.tv/ruby-rogues/195-rr-building-your-technology-radar-with-neal-ford">technology radar</a> in order to better structure my learning in the next six months. Without further ado here are the technologies that are currently on my radar.</p>
<h2 id="ansible">Ansible</h2>
<p><em>trial</em></p>
<p>I’ve used Chef and found the experience frustrating. I’m trialling Ansible to see if turns out to be a smaller and simpler automation solution by writing a playbook to manage deployment and provisioning of a small Haskell web service that I wrote at work.</p>
<p><a href="http://www.ansible.com" class="uri">http://www.ansible.com</a></p>
<h2 id="apache-kafka">Apache Kafka</h2>
<p><em>trial</em></p>
<p>Kafka is <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">publish-subscribe</a> messaging rethought as a distributed <a href="https://stackoverflow.com/questions/2582889/what-is-a-commit-log">commit log</a>. It looks like a mature and well-designed project and I hope to pilot it at work by designing and implementing a real-time notification engine.</p>
<p><a href="https://kafka.apache.org" class="uri">https://kafka.apache.org</a></p>
<h2 id="haskell">Haskell</h2>
<p><em>adopt</em></p>
<p>I’m already totally sold on Haskell. The type system offers a powerful way to capture invariants and explore solution space in a very abstract way, whilst the type checker provides fast feedback about whether our programs adhere to these invariants. I hope to write a lot more Haskell this year.</p>
<p><a href="https://www.haskell.org" class="uri">https://www.haskell.org</a></p>
<h2 id="purescript">Purescript</h2>
<p><em>assess</em></p>
<p>I have to write a lot of JavaScript and I really don’t like that I have to write a lot of JavaScript. I’m hoping that Purescript’s type system can help alleviate some of this pain.</p>
<p><a href="http://www.purescript.org" class="uri">http://www.purescript.org</a></p>
<h2 id="rust">Rust</h2>
<p><em>assess</em></p>
<p>Rust’s type system provides hope that someone like me could do systems programming without shooting themselves in the foot. I suspect it’s a language worth learning before it hits version <code>1.0</code> in a few months’ time.</p>
<p><a href="http://www.rust-lang.org" class="uri">http://www.rust-lang.org</a></p>
<h2 id="snap">Snap</h2>
<p><em>assess</em></p>
<p>Snap is web development framework written in Haskell. It occupies an exciting position in relation to other Haskell web frameworks in that it’s larger than <a href="http://hackage.haskell.org/package/scotty">Scotty</a> but smaller than <a href="http://hackage.haskell.org/package/yesod">Yesod</a>. It has a few interesting ideas, including an abstraction called <a href="http://snapframework.com/docs/tutorials/snaplets-tutorial">snaplets</a> that enable self-contained pieces of functionality to be easily composed.</p>
<p><a href="http://snapframework.com" class="uri">http://snapframework.com</a></p>
<h2 id="socket.io">Socket.IO</h2>
<p><em>trial</em></p>
<p>I’m planning to use Socket.IO as part of the real-time notification engine at work. It looks like a mature project that has traction in the <code>js</code> community and there’s already a Haskell implementation of the protocol <a href="https://hackage.haskell.org/package/socket-io">available on Hackage</a>.</p>
<p><a href="http://socket.io" class="uri">http://socket.io</a></p>
    </div>
  </section>
</div>

      </div>
    </div>
  </body>
</html>
